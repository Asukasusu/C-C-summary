# C/**C++**总结

## 一、C/C++基础

### 1、C++特点

1、C++在C语言的基础上引入了**面向对象**的机制、同时**兼容C语言**

2、C++三大特性1）封装、2）继承、3）多态；

​      1）**封装**  将属性和相关方法**封装**在一个**对象**中，对外部隐藏内部具体实现细节，外界只需要根据”**内部提供的接口**“去使用即可

​                       1、使用方便，因为已经将相关的功能封装为一个整体类似于工具箱、对不同的场景使用不同的工具箱

​                       2、保证数据的安全性；成员属性可以设置为private、protected；也可以设置为const，也可以拦截数据的写操作

​                       3、利于代码维护，如果后期需要修改，可直接修改类内部的代码；只需保证接口名不变

​      2）**继承**   一个类”拥有“另一个类的”资源“的一种方式；并不意味资源的复制、编程双份资源；而是，资源的使用权

|      继承方式       |      public继承       |     protected继承     |     private继承     |
| :-----------------: | :-------------------: | :-------------------: | :-----------------: |
|  父类的public成员   |  变为子类public成员   | 变为子类protected成员 | 变为子类private成员 |
| 父类的protected成员 | 变为子类protected成员 | 变为子类protected成员 | 变为子类private成员 |
|  父类的private成员  |        不可见         |        不可见         |       不可见        |

​                       1、父类中private成员在子类不可见，只子类继承了父类的private的成员，但是语法限制了子类对象或子类都不能访问

​                       2、protected成员能被**类**及**子类**直接访问；private子类的成员函数中不可以访问，只能通过父类public函数间接访问

​                       3、class类默认是private继承方式，struct默认是public继承方式；最好显示写出继承方式

​                       4、子类和父类都有独立的作用域，其中子类将屏蔽对父类同名成员的直接访问，称为隐藏(可在子类中使用父类::成员)

​      3）**多态**   **静态多态**：模板函数、函数重载；**动态多态**：父类/基类的指针或引用调用重写虚函数

3、C++编写的程序结构清晰、易于扩充，程序可读性好；更加安全、增加了引用、四类cast转化、智能指针、try-catch、auto等；

4、C++可重复性高、C++引入**模板**概念、标准模板库STL(Standard Template Library)

### 2、C与C++的区别

1、C是C++的子集，C++可以兼容C；C面向过程、C++面向对象

2、C语言存在不安全的语言特性、如指针使用的潜在危险、强制转化的不确定性、内存泄漏；C++增加新特性如：引用、cast转化

3、C++可重复性高、引入了模板概念，C++的库比C语言库更灵活、通用；

### 3、C++中struct和class区别

1、C语言中struct只能包含成员变量、不能包含成员函数；C++中struct描述数据结构集合，class描述对象数据的封装；

2、C++中struct默认是public，class默认是private；继承中struct默认public继承，class默认private继承；

3、class关键字可以用于定义模板参数，如typename，而struct不能用于定义模板参数

### 4、include 头文件的顺序<>和""的区别

1、**<>**的头文件是**系统文件**，**""**的头文件是**自定义文件**；编译器预处理阶段查找头文件的路径不一样；

2、**<>**的头文件查找路径：编译器设置的头文件路径-->系统变量

3、" ''的头文件查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

### 5、C++和C结构体区别

1、C结构体中不允许有函数；C++允许有内部成员函数，且允许是虚函数

2、C结构体内部只能是public；C++允许public、protected、privat；

3、C结构体不允许继承；C++结构体可以继承

### 6、导入C函数的关键字，C++和C编译的区别

1、在C++中，以extern "C"导入C函数，目的使C++代码能正确的调用C语言代码，且这部分代码以C语言进行编译

2、C++支持函数重载，因此编译器编译函数过程中会将参数类型也编译到代码里，不仅仅是函数名；C一般只包括函数名；

### 7、C++代码到可执行二进制文件

C/C++，从源码到可执行文件，有四个过程，预编译、编译、汇编、链接；

**预编译：**

1、将所有的#define删除，并展开所有的宏定义

2、处理所有的条件预编译指令，如#if、#ifdef

3、处理所有#include预编译指令，将所有被包含文件插入该预编译指令的位置

4、过滤注释、添加行号和文件名标识

**编译：**

1、词法分析：将源码的字符序列分割成一系列的记号

2、语法分析：对词法进行分析，产生语法树

3、语义分析：判断代码是否有意义

4、代码优化、生成汇编代码

**汇编：**主要将汇编代码转化为机器可以执行的置零

**链接：**将不同的源文件产生的目标文件进行链接，从而生成一个可执行文件

1、静态链接：在链接时就将要调用的函数或着过程链接到可执行文件，后删除静态库也不影响可执行程序；Win-.lib, Linux-.a

2、动态链接：在执行的过程中找要链接的函数，生成的可执行文件中没有函数代码只包含函数的重定位信息；Win-.dll, Linux-.oa

### 8、static关键字的作用

1、定义全局和局部静态变量：初始化的数据分配在.dat段，未初始化的数据分配在.bss段；直到程序结束。

2、定义静态函数和静态变量：只能在本源文件中作用；**C中在代码执行之前属于编译期初始化、C++中仅当对象首次使用时构造**

3、定义类的静态成员变量：可作为全局变量去存储但被隐藏在类内部，类中static拥有一块单独的存储空间，为类对象所共享；

4、定义类的静态成员函数：也是类的一部分，不是对象的一部分。为所有对象所共享；

当调用一个对象非静态成员函数时，系统会将对象的起始地址赋值给成员函数this指针。**而静态成员函数不属于对象，因此C++规定静态成员函数没有this指针。**既然没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

### 9、数组和指针的区别

1、数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址

2、指针：指针是一个变量，存放的是其他变量在内存中的首地址

1、赋值：同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝

2、存储方式：数组连续存储，存放在静态区或栈上。指针本身就是变量，存放的也是变量，所以指针的存储空间不能确定

3、sizeof：数组sizeof(数组名)/sizeof(数据类型)，指针变量在32位平台4字节，64位8字节；

### 10、函数指针和指针函数的区别

```c++
int  func(int a);  //普通函数
int* func(int a);  //指针函数
int  (*f)(int a);  //函数指针
f = func;
```

指针函数返回数是指针类型；函数指针是指向函数的指针变量，应用场景：回调(Callback)，调用别人提供的API函数(Application Programming Interface，应用程序接口);

### 11、nullptr调用成员函数

```c++
#include<iostream>
using namespace std;

class A
{
public:
	void func1()
	{
		//_a = 1;
	}
	virtual void func2()
	{
		
	}
private:
	 int _a = 10 ;
};

int main()
{
	A *p = nullptr;
	p->func1();
	p->func2();
	system("pause");
	return 0;
}
```

可以，对于类成员函数，并不是一个对象对应一个单独的**成员函数体**，而是此类**所有对象共用**，当程序编译之后，此**成员函数地址**就**确定**了，当调用**p->func1()时，其实就是在调用A::func1(this)**；当用空指针调用成员函数，只是让this指针指向空，所以空指针也可以调用普通成员函数，但是函数func1()内部并没有用到this指针，所以不会出现问题。

**空指针不能调用虚函数**：如果类中包含虚函数，他所实例化对象的前四个字节是一个虚表指针，其指向的是虚函数表；虚函数的地址也是在编译时就确定了，虚函数地址存放在虚函数表里面，而虚函数表就在程序地址空间的数据段（静态段）

### 12、什么是野指针

1、概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

2、产生原因：释放内存后指针不及时置空，依然指向了该内存，可能出现非法访问的错误。

3、避免办法：**初始化置NULL、申请后判断空、指针释放后置NULL、使用智能指针；**

### 13、静态变量、全局变量、局部变量的特点以及使用场景

1、作用域：C++作用域分为6种，**全局、局部、类、语句、命名空间**和**文件作用域**。

2、空间域：除了局部变量在栈上、其他都存储在静态存储区。

3、生命周期：局部变量在栈上，出了作用域就会回收内存；其他都在静态存储区，直到程序结束才会回收内存；

### 14、内联函数inline和宏函数的区别

1、**宏函数：不是函数**，**预处理**器用复制宏代码替代了函数调用，即字符替换，省去了函数压栈退栈的过程，提高了效率；

2、**内联函数：**一般用于函数体代码较为简单的函数，不能包含复杂的控制语句如while、switch等，内联函数本身不能调用自身；

​      内联函数在编译的时候进行代码插入，编译器在每处调用内联函数的地方直接把内联函数展开，省去函数调用开销，提高效率；

​      普通函数被调用时需要寻址（函数入口）；内联函数不需要寻址；内联函数在调用时，是将**调用表达式用内联函数体来替换**。避

​      免函数调用的开销。

3、**宏定义是没有类型检查的**，无论对错直接替换；内联函数在编译时候会进行类型检查，满足函数性质，如有返回值、参数列表；

**内联函数使用代价**

1、内联是以代码膨胀(复制)为代价，仅仅是省去函数调用开销，从而提升函数的执行效率

2、内联不是什么时候都能展开的，一个好的编译器会根据函数的定义体，自动取消不符合要求的内联；以下情况不宜使用

​      1）函数体内**代码较长**，使用内联将导致内存消耗代价高

​      2）函数体内**出现循环**，那么执行函数体内代码的时间要比函数调用开销大

### 15、new和malloc的区别

1、**new是操作符**，new在调用时先分配内存，在调用构造函数，释放是调用析构函数；不用指定内存大小，返回值不用强转；

2、**malloc是库函数**，malloc没有构造函数和析构函数；需要给定申请内存大小，返回值需要强制转化；

3、new可以被重载，new从**自由存储区**(heap、静态存储区)上为对象动态分配内存控制；malloc不可以重载，heap上分配；

4、new分配内存更直接和安全；

5、new发生错误抛出异常，使用new[]分配的内存必须使用delete[]进行释放；malloc异常返回NULL；

**malloc底层实现：**当开辟空间小于128K时，调用brk()函数；大于128K时，调用mmap()函数。malloc采用的是内存池的管理方式，以减少内存碎片；先申请大块内存作为heap区，将heap分为多个内存块，用户申请内存时，直接从heap分配一块合适的空闲块。采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块； 同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

**new底层原理：**关键字new在调用构造函数时实际进行如下几个步骤：

1、创建一个新的对象

2、将构造函数的作用域赋值给这个新对象（因此this指向了这个新的对象）

3、执行构造函数中的代码（为这个新对象添加属性）

4、返回新对象

### 16、const和define的区别

const用以定义常量；define用于定义宏，而宏可以用于定义常量。

1、const生效于编译的阶段；define生效于预编译阶段。

2、const定义的常量，在C语言中是**存储在内存中、需要额外内存空间**；define定义的常量运行时是直接的操作数，不存放内存中；

3、const定义的常量是带类型的；define定义的常量不带类型。define定义的常量不利于类型检测。

### 17、常量指针和指针常量

```C++
1. const int  a;  // 常量
2. const int *a;  // 常量指针 point to const a所指向的内存里的值不变 *a不变
3. int const *a;  // 同上

4. int *const a;  // 指针常量 const point    a所指向的地址值不可变  *a可变
5. const int *const a; // a不变 *a也不变
```

### 18、使用指针需要注意什么

1、定义指针时，先**初始化为NULL**；

2、malloc申请内存之后，应该立即**检测指针值是否为NULL**，防止使用指针值为NULL的内存。new应当使用try catch机制；

3、不要忘记为数组和动态内存**赋初值**。防止将未初始化的内存作为右值使用。

4、避免数字或指针的下标**越界**，当心多一或少一操作。

5、动态内存的**申请与释放必须配对**，防止内存泄漏。

6、用free或delete释放内存之后，将指针置为NULL；

### 19、C++传值方式：值传递、引用传递、指针传递

1、值传递：形参在函数体发生改变，也不影响实参的值；值传递对象时，整个对象会**拷贝一个副本**，**效率低**；

2、引用传递：形参在函数体内改变，会影响实参的值；传递时**不发生拷贝**，只绑定对象，类似于const point；

3、指针传递：指针指向没有改变时，形参改变实参也改变；同引用传递，但**没有引用传递安全**；





## 二、C++内存

### 1、堆和栈的区别

1、**堆栈空间分配不同。**栈由**操作系统自动分配释放**，存放函数的参数值，局部变量的值等；**堆由程序员分配释放**

2、**堆栈缓存方式不同**。**栈使用**的是**一级缓存**，通常是被调用时处于存储空间，调用完立即释放；堆是**存放在**二级缓存，速度较慢；

3、**堆栈数据结构不同。**堆类似数组结构；栈类似栈结构，先进后出。

### 2、C++内存管理

1、在C++中，内存分为5个区，堆、栈、自由存储区、全局/静态存储区和常量存储区

​      栈：执行函数时，函数内部局部变量的存储单元都可以在栈上创建，函数执行完毕自动释放

​      **堆：由malloc分配的内存块，用free结束生命**

​      **自由存储区：由new分配的内存块，一般一个new对应一个delete**

​      全局/静态存储区：全局变量和静态变量被分配到同一块内存中

​      常量存储区：存放常量的存储区，一般不允许修改

**堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。**

2、常见内存错误

​      (1) 内存分配未成功，却使用了；

​      (2) 内存分配虽然成功，但未初始化

​      (3) 内存分配成功也初始化，但操作越过了内存边界

​      (4) 未能释放内存，造成内存泄漏

​      (5) 释放了内存，但继续使用 

​      对策

​      (1) 定义指针时，先初始化为NULL

​      (2) 用malloc和new申请内存后，判断是否为NULL，防止使用指针值为NULL的内存

​      (3) 不要忘记为数组和动态内存赋初值，防止将未初始化的内存作为右值

​      (4) 避免数字或指针下标越界

​      (5) **动态内存的申请和释放必须配对，防止内存泄漏**

​      (6) 动态内存释放之后，立即将指针置为NULL

​      (7) 使用野指针

3、**内存泄漏**以及**解决办法**

​      简单来说就是**申请了一块内存空间，使用完毕后没有释放掉**

​      (1) new和malloc申请资源使用后，没有用delete和free释放掉

​      (2) **子类继承父类时，父类的析构函数不是虚函数**

​      (3) windows句柄资源使用后没有释放

​      检测办法

​      (1) 良好的编码习惯，使用内存分配函数要使用对应的函数释放内存

​      (2) 将分配的内存的指针以链表形式自行管理，使用完毕之后从链表中删除

​      (3) 使用智能指针

​      (4) 一些常用工具插件，ccmalloc、Dmalloc、Leaky、Valgrind等

### 3、程序上有哪些section，分别是什么作用、程序启动过程

![](./image/section.png)

1、代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读常数

2、数据段：data段存放已初始化的全局变量和静态变量的一块内存区域

3、bss段：  存放未初始化或零初始化的全局变量和静态变量的一块区域

​      [.data和.bss分开的理由：](https://blog.csdn.net/JMW1407/article/details/108185440)

​      1）.text段部分是编译后程序的主体，也就是程序的机器指令。

​      2）.text段和.data段都在可执行文件中(嵌入式系统中一般固化在镜像文件中)，由系统从可执行文件中加载

​      3）.bss段不在可执行文件中，由系统初始化

4、可执行文件运行时的两个区：堆区和栈区

​      堆区：动态申请内存用。堆从低地址向高地址生长。

​      栈区：存储局部变量、函数参数值。栈由高地址向低地址增长。

5、文件映射区、位于堆和栈之间

**程序启动过程**

1、操作系统首先**创建相应的进程**并分配**私有的进程空间**，然后操作系统加载器把可执行文件的数据段和代码段**映射**到进程的**虚拟空间**

2、加载器读入可执行程序的**导入符号表**，根据符号表**查找**可执行程序所有依赖的**动态链接库**

3、加载器针对该程序的每一个动态链接库调用LoadLibrary

​      1）查找对应的动态文件库，加载器为动态链接库**确定**一个合适的**基地址**

​      2）加载器读取该动态链接库的导入符号表和导出符号表，比较程序的导入符号是否比配该库的导出符号

​      3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳转到3

​      4）调用该动态链接库的初始化函数

4、初始化应用程序的全局变量，对于全局对象自动调用构造函数。

5、进入应用程序入口点函数开始执行

### 4、C++中内存对齐的使用场景

内存对齐应用于三种数据类型中：struct、class、union；对齐规则：

1、数据成员对齐规则：结构体(struct)或联合体(union)的数据成员，第一个数据放在offset为0的地方，以后每个数据成员存储的**起始位置从该成员大小或者子成员大小的整数倍开始**

2、结构体成为成员：如果一个结构体里有某些结构体成员，则结构体成员要从其**内部最宽基本类型成员的整数倍**地址开始存储。

3、收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的最宽基本类型成员的整数倍。不足补齐（基本类型不包括struct、class、union）

4、sizeof(union)，以联合体里面size最大的元素为union的size。

为了使CPU能够对变量进行快速访问，变量的起始地址应该具有某些特性，即所谓对齐，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能被4整除，对齐跟数据在内存中的位置有关。如果变量的内存地址正好位于它长度的整数倍，它就称为自然对齐。

为了快速准确的访问，若没有字节对齐则会出现多次访问浪费时间。





## 面向对象

### 1、面向对象与面向过程

1、面向对象是一种编程思想，把一切东西看成一个个对象，将这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类表示

2、面向对象和面向过程的区别

​      面向过程：根据业务逻辑从上到下写代码

​      面向对象：将数据与函数绑定，进行封装，加快开发程序，减少重复代码。

### 2、简述C++的重写和重载，以及它们的区别

1、**重写**：子类中存在重新定义的函数，其**函数名，参数列表，返回值类型**，所有都必须同**父类**中被重写**的函数一致**。**只有函数体不同**（花括号内）。重写的函数在**父类中必须有virtual修饰**。

```c++
#include <bits/stdc++.h>
using namespace std;

class A
{
    public:
        virtual void fun()
        {
            cout << "a" << endl;
        }
};

class B : public A
{
    public:
        virtual void fun()
        {
            cout << "b" << endl;
        }
};

int main()
{
    A* a = new B();
    a->fun(); // 输出b，A类中的fun在B类中重写
}
```

2、**重载**：**相同作用域**(比如命名空间或者同一个类)内拥有**相同的方法名**，但具有**不同的参数类型和/或参数数量**的方法。 重载允许根据所提供的**参数不同**来调用不同的函数。返回类型可以相同或不同。

```C++
#include <bits/stdc++.h>

class A
{
void fun() {};
void fun(int i) {};
void fun(int i, int j) {};
void fun1(int i,int j){};
};
```

3、**隐藏**：**子类**的函数**屏蔽**了与其**同名的父类函数**。只要是同名函数，不管参数列表是否相同，父类函数都会被隐藏。

```C++
#include<iostream>
using namespace std;

class A {
public:
  /* 并非virtual修饰 所以不是重写*/
  void fun1(int i, int j){
    cout <<"A::fun1() : " << i <<" " << j << endl;
  }
};
class B : public A {
public:
  //隐藏
  void fun1(double i){
    cout <<"B::fun1() : " << i << endl;
  }
};
int main(){
  B b;
  b.fun1(5);//调用B类中的函数
  b.fun1(1, 2);//出错，因为基类函数被隐藏
  b.A::fun1(1, 2);//使用父类作用域来调用A中fun1()
  system("pause");
  return 0;
}
```

**重载和重写的区别：**

1、范围区别：**重写**和被重写的函数**不在**同一类中，**重载**和被重载的函数**在**同一类中（同一作用域）

2、参数区别：**重写**和被重写的**函数参数列表**一定**相同**，**重载**和被重载的**函数参数列表**一定**不同**

3、virtual区别：重写的父类必须有virtual修饰，重载函数可以被virtual修饰，也可以没有

**隐藏、重写和重载的区别：**

1、与重载范围不同：隐藏函数和被隐藏函数在不同类中；

2、参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数列表不同时，无论父类中的函数是否被virtual修饰，其父类函数都是被隐藏，而不是被重写；

### 3、C++的重载和重写是如何实现的

1、**重载：**C++利用命名倾轧（name mangling）技术，来改变函数名，区分参数不同的同名函数。命名倾轧是在**编译**阶段完成的。编译时将参数类型加入以区分不同。

2、**重写：**在父类的函数前加上virtual关键字，在子类中重写该函数，运行时**根据对象**的**类型**来**调用相应的函数**。对象类型是子类就调用子类的函数，对象是父类就调用父类函数。

虚函数需要注意的地方：

​        1）virtual关键字声明的函数叫做虚函数，虚函数肯定是类的成员函数

​        2）存在虚函数的类都有一个一维的虚函数表（虚表），类的对象有一个指向虚表开始的虚指针。**虚表和类对应，虚表指针和对象对应**

​        3）**多态性是一个接口多种实现**，是面向对象和核心，分为类的多态性和函数的多态性。

​        4）重写用虚函数来实现，结合动态绑定。纯虚函数是虚函数再加上 = 0.

​        5）抽象类是指至少包含一个纯虚函数的类。

#### 4、构造函数的种类，以及作用

C++中构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数和移动构造函数

1、**默认构造函数**和**初始化构造函数**，有了有参的构造，编译器就不提供默认的构造函数。

```C++
class Student
{
    public:
        //默认构造函数
        Student()
        {
            num=1001;
            age=18;
        }
        //初始化构造函数
        Student(int n,int a):num(n),age(a){}
    private:
        int num;
        int age;
};
int main()
{
    //用默认构造函数初始化对象S1
    Student s1;
    //用初始化构造函数初始化对象S2
    Student s2(1002,18);
    return 0;
}
```

2、**拷贝构造函数**，赋值构造函数默认实现的是值拷贝（**浅拷贝**）。

```C++
class Test
{
    private:
        int i;
        int *p;
    public:
        Test(int ai,int value)
        {
            i = ai;
            p = new int(value);
        }
        ~Test()
        {
            delete p;
        }
        Test(const Test& t)
        {
            this->i = t.i;
            this->p = new int(*t.p);
        }
};
//复制构造函数用于复制本类的对象
int main(int argc, char* argv[])
{
    Test t1(1,2);
    Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同
    return 0;
}

```

3、**移动构造函数**，将临时对象的资源直接移交给接收对象，那么就可以减少一次拷贝。

```c++
#include <iostream>

class MyObject {
    private:
        int* data;

    public:
        MyObject() : data(nullptr) {
            std::cout << "Default Constructor" << std::endl;
        }

        MyObject(int value) : data(new int(value)) {
            std::cout << "Regular Constructor" << std::endl;
        }

        // 移动构造函数
        MyObject(MyObject&& other)noexcept : data(other.data) {
            other.data = nullptr;
            std::cout << "Move Constructor" << std::endl;
        }

        ~MyObject() {
            delete data;
            std::cout << "Destructor" << std::endl;
        }

        void printData() const {
            if (data != nullptr) {
                std::cout << "Data: " << *data << std::endl;
            } else {
                std::cout << "Data is null" << std::endl;
            }
        }
};

int main() {
    MyObject obj1(10);
    obj1.printData();

    MyObject obj2(std::move(obj1));  // 使用std::move调用移动构造函数
    obj2.printData();
    
    obj1.printData();  // obj1的data现在为null

    return 0;
}
/*
Regular Constructor
Data: 10
Move Constructor
Data: 10
Data is null
Destructor
Destructor
*/
```

### 5、只定义析构函数，会自动生成那些构造函数

只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。

### 6、一个类默认会生成哪些函数

无参的构造函数、拷贝构造函数、[赋值运算符](https://blog.csdn.net/michellechouu/article/details/47298445)、析构函数（非虚）

### 7、C++类对象初始化顺序

1、创建子类对象时，父类的构造函数优先被调用（也优先于子类中成员类）

2、如果类里面有成员类，成员类的构造函数优先被调用（也优先于本省的构造函数）

3、[继承顺序、声明顺序](https://blog.csdn.net/IEEEITU/article/details/6785925)

**父类构造函数–>成员类对象构造函数–>自身构造函数**

**析构顺序和构造顺序相反**

### 8、简述向上转型和向下转型

1、子类转化为父类：**向上转型**，使用dynamic_cast(expression)，这种转换相对安全不会有数据丢失

2、父类转化为子类：**向下转型**，强制转换，不安全会导致数据丢失；**原因是父类的指针或引用的内存中可能不包含子类的成员的内存**。

### 9、深拷贝和浅拷贝，如何实现[深拷贝](https://zhuanlan.zhihu.com/p/649768559)

1、浅拷贝：将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份
实体，只是所引用的变量名不同，**地址其实还是相同**的。

2、深拷贝：候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中
去，这样两个指针就指向了**不同的内存**位置。并且里面的**内容是一样**的

### 10、为什么要虚析构、不能虚构造

1、虚析构：将可能被继**承的父类的析构函数设置为虚函数**，可以保证在new一个子类时，用父类指针指向该子类对象，释放父类指针时也可以释放子类的空间，**防止内存泄漏**。子类指针指向子类对象时不管析构函数是否是虚函数，都会正常析构；父类指针指向子类对象时，析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数

**C++默认析构函数不是虚函数，因为虚函数需要额外的虚函数表和虚表指针，占用额外内存**。

2、不能虚构造：

内存角度：**虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的**，如果构造函数设置为虚函数，就需要到vtable中调用，但是对象还未实例化，没有分配内存空间，不能调用。

使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，使用虚函数也没有实际意义。构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

### 11、模板类是什么时候实现的

1、[模板实例化](https://cloud.tencent.com/developer/article/2414744)

​      1）隐式实例化：在编译过程中由编译器来决定使用什么类型来实例化一个模板，不管是显示实例化还是隐式实例化，最终生成的类或者函数按照模板的定义来实现

```C++
template<typename T>
T add(T t1, T2)
{
    return t1 + t2;
}
 
template<typename T>
class Dylan
{
public:
    T m_data;
};
 
int main()
{
    int ret = add(3,4); //隐式实例化，int add<int>(int t1, int t2);
    Dylan<double> dylan;//隐式实例化
}
```

​      2）显示实例化：开发者明确模板应该使用什么样的类型去生成具体的类或函数，比隐式实例化时更快速，从而省去运行阶段创建这个类的时间。

```c++
extern template int add<int>(int t1, int t2);//显式实例化声明
extern template class Dylan<int>;            //显式实例化声明
 
template int add<int>(int t1, int t2);       //显式实例化定义
template class Dylan<int>;                   //显式实例化定义
```

2、[模板具体化](https://qixinbo.info/2017/07/09/cplusplus-template/)

当模板使用某种类型实例化后的类或函数不能满足需要时，可以对模板进行具体化，具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型具体处理

```c++
// 定义函数模板，找出三个值中最小的值，与数据类型无关
template <class T>
T min(T ii, T jj, T kk)
{
    T temp;
    if((ii<jj)&&(ii<kk)){        temp=ii;    }
    else if((jj<ii)&&(jj<kk)){        temp=jj;    }
    else    {        temp=kk;    }
    return temp;
}
//非模板函数重载
const char* min(const char* ch1, const char* ch2,const char* ch3)
{
    const char* temp;
    int result1 = strcmp(ch1,ch2);
    int result2 = strcmp(ch1,ch3);
    int result3 = strcmp(ch2,ch1);
    int result4 = strcmp(ch2,ch3);
    if((result1<0)&&(result2<0))    {        temp = ch1;    }
    else if((result3<0)&&(result4<0))    {        temp=ch2;    }
    else    {        temp=ch3;    }
    return temp;
}
```

### 12、类继承时，子类对不同关键字修饰的父类方法访问权限

类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。

1. public继承：子类可以访问父类的public、protected成员，不可以访问父类的private成员；子类对象可以访问父类的public成员，不可以访问父类的protected、private成员。
2. protected继承：子类可以访问父类的public、protected成员，不可以访问父类的private成员；子类对象不可以访问父类的public、protected、private成员。
3. private     继承：子类可以访问父类的public、protected成员，不可以访问父类的private成员；子类对象不可以访问父类的public、protected、private成员。

### 13、常函数

类的成员函数后面加上const，表明这个函数不会对这个类对象的数据成员（即非静态数据）作任何改变。**原则就是对于不改变数据成员的成员函数都要在后面加const**。[权限问题](https://blog.csdn.net/weixin_45031801/article/details/134161230)

1. **const成员函数**可以访问**非const对象**的**非const数据成员**、**const数据成员**，也可以访问**const对象**内**所有的数据成员**；
2. **非const成员函数**可以访问**非const对象**的**非const数据成员**、**const数据成员**，但**不可以**访问**const对象**的任意**数据或成员**；
3. 如只有const成员函数，非const对象可以调用const成员函数。当const和非const成员函数同时出现时，非const对象调用非const成员函数

如果类中存在指针类型的数据成员，const成员函数只能保证不能修改指针值，不能保证不修改指针所指对象

### 14、虚继承

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一父类，会在子类中存在多分拷贝。这将导致两个问题：其一，浪费存储空间；其二，存在二义性。
