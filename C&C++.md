# C/**C++**总结

## 一、C/C++基础

### 1、C++特点

1、C++在C语言的基础上引入了**面向对象**的机制、同时**兼容C语言**

2、C++三大特性1）封装、2）继承、3）多态；

​      1）**封装**  将属性和相关方法**封装**在一个**对象**中，对外部隐藏内部具体实现细节，外界只需要根据”**内部提供的接口**“去使用即可

​                       1、使用方便，因为已经将相关的功能封装为一个整体类似于工具箱、对不同的场景使用不同的工具箱

​                       2、保证数据的安全性；成员属性可以设置为private、protected；也可以设置为const，也可以拦截数据的写操作

​                       3、利于代码维护，如果后期需要修改，可直接修改类内部的代码；只需保证接口名不变

​      2）**继承**   一个类”拥有“另一个类的”资源“的一种方式；并不意味资源的复制、编程双份资源；而是，资源的使用权

|      继承方式       |      public继承       |     protected继承     |     private继承     |
| :-----------------: | :-------------------: | :-------------------: | :-----------------: |
|  父类的public成员   |  变为子类public成员   | 变为子类protected成员 | 变为子类private成员 |
| 父类的protected成员 | 变为子类protected成员 | 变为子类protected成员 | 变为子类private成员 |
|  父类的private成员  |        不可见         |        不可见         |       不可见        |

​                       1、父类中private成员在子类不可见，只子类继承了父类的private的成员，但是语法限制了子类对象或子类都不能访问

​                       2、protected成员能被**类**及**子类**直接访问；private子类的成员函数中不可以访问，只能通过父类public函数间接访问

​                       3、class类默认是private继承方式，struct默认是public继承方式；最好显示写出继承方式

​                       4、子类和父类都有独立的作用域，其中子类将屏蔽对父类同名成员的直接访问，称为隐藏(可在子类中使用父类::成员)

​      3）**多态**   静态多态：模板函数、函数重载；动态的多态：父类/基类的指针或引用调用重写虚函数

3、C++编写的程序结构清晰、易于扩充，程序可读性好；更加安全、增加了引用、四类cast转化、智能指针、try-catch、auto等；

4、C++可重复性高、C++引入**模板**概念、标准模板库STL(Standard Template Library)

### 2、C与C++的区别

1、C是C++的子集，C++可以兼容C；C面向过程、C++面向对象

2、C语言存在不安全的语言特性、如指针使用的潜在危险、强制转化的不确定性、内存泄漏；C++增加新特性如：引用、cast转化

3、C++可重复性高、引入了模板概念，C++的库比C语言库更灵活、通用；

### 3、C++中struct和class区别

1、C语言中struct只能包含成员变量、不能包含成员函数；C++中struct描述数据结构集合，class描述对象数据的封装；

2、C++中struct默认是public，class默认是private；继承中struct默认public继承，class默认private继承；

3、class关键字可以用于定义模板参数，如typename，而struct不能用于定义模板参数

### 4、include 头文件的顺序<>和""的区别

1、**<>**的头文件是**系统文件**，**""**的头文件是**自定义文件**；编译器预处理阶段查找头文件的路径不一样；

2、**<>**的头文件查找路径：编译器设置的头文件路径-->系统变量

3、" ''的头文件查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

### 5、C++和C结构体区别

1、C结构体中不允许有函数；C++允许有内部成员函数，且允许是虚函数

2、C结构体内部只能是public；C++允许public、protected、privat；

3、C结构体不允许继承；C++结构体可以继承

### 6、导入C函数的关键字，C++和C编译的区别

1、在C++中，以extern "C"导入C函数，目的使C++代码能正确的调用C语言代码，且这部分代码以C语言进行编译

2、C++支持函数重载，因此编译器编译函数过程中会将参数类型也编译到代码里，不仅仅是函数名；C一般只包括函数名；

### 7、C++代码到可执行二进制文件

C/C++，从源码到可执行文件，有四个过程，预编译、编译、汇编、链接；

**预编译：**

1、将所有的#define删除，并展开所有的宏定义

2、处理所有的条件预编译指令，如#if、#ifdef

3、处理所有#include预编译指令，将所有被包含文件插入该预编译指令的位置

4、过滤注释、添加行号和文件名标识

**编译：**

1、词法分析：将源码的字符序列分割成一系列的记号

2、语法分析：对词法进行分析，产生语法树

3、语义分析：判断代码是否有意义

4、代码优化、生成汇编代码

**汇编：**主要将汇编代码转化为机器可以执行的置零

**链接：**将不同的源文件产生的目标文件进行链接，从而生成一个可执行文件

1、静态链接：在链接时就将要调用的函数或着过程链接到可执行文件，后删除静态库也不影响可执行程序；Win-.lib, Linux-.a

2、动态链接：在执行的过程中找要链接的函数，生成的可执行文件中没有函数代码只包含函数的重定位信息；Win-.dll, Linux-.oa

### 8、static关键字的作用

1、定义全局和局部静态变量：初始化的数据分配在.dat段，未初始化的数据分配在.bss段；直到程序结束。

2、定义静态函数和静态变量：只能在本源文件中作用；**C中在代码执行之前属于编译期初始化、C++中仅当对象首次使用时构造**

3、定义类的静态成员变量：可作为全局变量去存储但被隐藏在类内部，类中static拥有一块单独的存储空间，为类对象所共享；

4、定义类的静态成员函数：也是类的一部分，不是对象的一部分。为所有对象所共享；

当调用一个对象非静态成员函数时，系统会将对象的起始地址赋值给成员函数this指针。**而静态成员函数不属于对象，因此C++规定静态成员函数没有this指针。**既然没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

### 9、数组和指针的区别

1、数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址

2、指针：指针是一个变量，存放的是其他变量在内存中的首地址

1、赋值：同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝

2、存储方式：数组连续存储，存放在静态区或栈上。指针本身就是变量，存放的也是变量，所以指针的存储空间不能确定

3、sizeof：数组sizeof(数组名)/sizeof(数据类型)，指针变量在32位平台4字节，64位8字节；

### 10、函数指针和指针函数的区别

```c++
int  func(int a);  //普通函数
int* func(int a);  //指针函数
int  (*f)(int a);  //函数指针
f = func;
```

指针函数返回数是指针类型；函数指针是指向函数的指针变量，应用场景：回调(Callback)，调用别人提供的API函数(Application Programming Interface，应用程序接口);

### 11、nullptr调用成员函数

```c++
#include<iostream>
using namespace std;

class A
{
public:
	void func1()
	{
		//_a = 1;
	}
	virtual void func2()
	{
		
	}
private:
	 int _a = 10 ;
};

int main()
{
	A *p = nullptr;
	p->func1();
	p->func2();
	system("pause");
	return 0;
}
```

可以，对于类成员函数，并不是一个对象对应一个单独的**成员函数体**，而是此类**所有对象共用**，当程序编译之后，此**成员函数地址**就**确定**了，当调用**p->func1()时，其实就是在调用A::func1(this)**；当用空指针调用成员函数，只是让this指针指向空，所以空指针也可以调用普通成员函数，但是函数func1()内部并没有用到this指针，所以不会出现问题。

**空指针不能调用虚函数**：如果类中包含虚函数，他所实例化对象的前四个字节是一个虚表指针，其指向的是虚函数表；虚函数的地址也是在编译时就确定了，虚函数地址存放在虚函数表里面，而虚函数表就在程序地址空间的数据段（静态段）

### 12、什么是野指针

1、概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

2、产生原因：释放内存后指针不及时置空，依然指向了该内存，可能出现非法访问的错误。

3、避免办法：**初始化置NULL、申请后判断空、指针释放后置NULL、使用智能指针；**

### 13、静态变量、全局变量、局部变量的特点以及使用场景

1、作用域：C++作用域分为6种，**全局、局部、类、语句、命名空间**和**文件作用域**。

2、空间域：除了局部变量在栈上、其他都存储在静态存储区。

3、生命周期：局部变量在栈上，出了作用域就会回收内存；其他都在静态存储区，直到程序结束才会回收内存；

### 14、内联函数inline和宏函数的区别

1、**宏函数：不是函数**，**预处理**器用复制宏代码替代了函数调用，即字符替换，省去了函数压栈退栈的过程，提高了效率；

2、**内联函数：**一般用于函数体代码较为简单的函数，不能包含复杂的控制语句如while、switch等，内联函数本身不能调用自身；

​      内联函数在编译的时候进行代码插入，编译器在每处调用内联函数的地方直接把内联函数展开，省去函数调用开销，提高效率；

​      普通函数被调用时需要寻址（函数入口）；内联函数不需要寻址；内联函数在调用时，是将**调用表达式用内联函数体来替换**。避

​      免函数调用的开销。

3、**宏定义是没有类型检查的**，无论对错直接替换；内联函数在编译时候会进行类型检查，满足函数性质，如有返回值、参数列表；

**内联函数使用代价**

1、内联是以代码膨胀(复制)为代价，仅仅是省去函数调用开销，从而提升函数的执行效率

2、内联不是什么时候都能展开的，一个好的编译器会根据函数的定义体，自动取消不符合要求的内联；以下情况不宜使用

​      1）函数体内**代码较长**，使用内联将导致内存消耗代价高

​      2）函数体内**出现循环**，那么执行函数体内代码的时间要比函数调用开销大

### 15、new和malloc的区别

1、**new是操作符**，new在调用时先分配内存，在调用构造函数，释放是调用析构函数；不用指定内存大小，返回值不用强转；

2、**malloc是库函数**，malloc没有构造函数和析构函数；需要给定申请内存大小，返回值需要强制转化；

3、new可以被重载，new从**自由存储区**(heap、静态存储区)上为对象动态分配内存控制；malloc不可以重载，heap上分配；

4、new分配内存更直接和安全；

5、new发生错误抛出异常，使用new[]分配的内存必须使用delete[]进行释放；malloc异常返回NULL；

**malloc底层实现：**当开辟空间小于128K时，调用brk()函数；大于128K时，调用mmap()函数。malloc采用的是内存池的管理方式，以减少内存碎片；先申请大块内存作为heap区，将heap分为多个内存块，用户申请内存时，直接从heap分配一块合适的空闲块。采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块； 同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

**new底层原理：**关键字new在调用构造函数时实际进行如下几个步骤：

1、创建一个新的对象

2、将构造函数的作用域赋值给这个新对象（因此this指向了这个新的对象）

3、执行构造函数中的代码（为这个新对象添加属性）

4、返回新对象

### 16、const和define的区别

const用以定义常量；define用于定义宏，而宏可以用于定义常量。

1、const生效于编译的阶段；define生效于预编译阶段。

2、const定义的常量，在C语言中是**存储在内存中、需要额外内存空间**；define定义的常量运行时是直接的操作数，不存放内存中；

3、const定义的常量是带类型的；define定义的常量不带类型。define定义的常量不利于类型检测。

### 17、常量指针和指针常量

```C++
1. const int  a;  // 常量
2. const int *a;  // 常量指针 point to const a所指向的内存里的值不变 *a不变
3. int const *a;  // 同上

4. int *const a;  // 指针常量 const point    a所指向的地址值不可变  *a可变
5. const int *const a; // a不变 *a也不变
```

### 18、使用指针需要注意什么

1、定义指针时，先**初始化为NULL**；

2、malloc申请内存之后，应该立即**检测指针值是否为NULL**，防止使用指针值为NULL的内存。new应当使用try catch机制；

3、不要忘记为数组和动态内存**赋初值**。防止将未初始化的内存作为右值使用。

4、避免数字或指针的下标**越界**，当心多一或少一操作。

5、动态内存的**申请与释放必须配对**，防止内存泄漏。

6、用free或delete释放内存之后，将指针置为NULL；

### 19、C++传值方式：值传递、引用传递、指针传递

1、值传递：形参在函数体发生改变，也不影响实参的值；值传递对象时，整个对象会**拷贝一个副本**，**效率低**；

2、引用传递：形参在函数体内改变，会影响实参的值；传递时**不发生拷贝**，只绑定对象，类似于const point；

3、指针传递：指针指向没有改变时，形参改变实参也改变；同引用传递，但**没有引用传递安全**；





## 二、C++内存

### 1、堆和栈的区别

1、**堆栈空间分配不同。**栈由**操作系统自动分配释放**，存放函数的参数值，局部变量的值等；**堆由程序员分配释放**

2、**堆栈缓存方式不同**。**栈使用**的是**一级缓存**，通常是被调用时处于存储空间，调用完立即释放；堆是**存放在**二级缓存，速度较慢；

3、**堆栈数据结构不同。**堆类似数组结构；栈类似栈结构，先进后出。

### 2、C++内存管理

1、在C++中，内存分为5个区，堆、栈、自由存储区、全局/静态存储区和常量存储区

​      栈：执行函数时，函数内部局部变量的存储单元都可以在栈上创建，函数执行完毕自动释放

​      **堆：由malloc分配的内存块，用free结束生命**

​      **自由存储区：由new分配的内存块，一般一个new对应一个delete**

​      全局/静态存储区：全局变量和静态变量被分配到同一块内存中

​      常量存储区：存放常量的存储区，一般不允许修改

**堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。**

2、常见内存错误

​      (1) 内存分配未成功，却使用了；

​      (2) 内存分配虽然成功，但未初始化

​      (3) 内存分配成功也初始化，但操作越过了内存边界

​      (4) 未能释放内存，造成内存泄漏

​      (5) 释放了内存，但继续使用 

​      对策

​      (1) 定义指针时，先初始化为NULL

​      (2) 用malloc和new申请内存后，判断是否为NULL，防止使用指针值为NULL的内存

​      (3) 不要忘记为数组和动态内存赋初值，防止将未初始化的内存作为右值

​      (4) 避免数字或指针下标越界

​      (5) **动态内存的申请和释放必须配对，防止内存泄漏**

​      (6) 动态内存释放之后，立即将指针置为NULL

​      (7) 使用野指针

3、**内存泄漏**以及**解决办法**

​      简单来说就是**申请了一块内存空间，使用完毕后没有释放掉**

​      (1) new和malloc申请资源使用后，没有用delete和free释放掉

​      (2) **子类继承父类时，父类的析构函数不是虚函数**

​      (3) windows句柄资源使用后没有释放

​      检测办法

​      (1) 良好的编码习惯，使用内存分配函数要使用对应的函数释放内存

​      (2) 将分配的内存的指针以链表形式自行管理，使用完毕之后从链表中删除

​      (3) 使用智能指针

​      (4) 一些常用工具插件，ccmalloc、Dmalloc、Leaky、Valgrind等

### 3、程序上有哪些section，分别是什么作用

![](.\image\section.png)

